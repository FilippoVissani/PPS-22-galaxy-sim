# Retrospettiva

## Scrum
Il metodo Scrum è stato utile per definire chiaramente quali fossero gli obiettivi da raggiungere da sprint a sprint per apportare valore all'utente. 
La suddivisione del tempo di sviluppo in sprint è stata una buona occasione per mantenere il team in stretto contatto con meeting e confronti frequenti nonostante la dislocazione dei membri durante gran parte dello sviluppo. Tuttavia, a causa di quest'ultima, non è stato possibile eseguire veri e propri stand-up meetings.

Il team tuttavia non può fare a meno di notare una difficoltà attraversata nel portare, al termine di ogni sprint, un prodotto funzionante che apportasse un valore aggiunto rispetto all'iterazione precedente, probabilmente figlia di difficoltà nello stimare l'effort e la priorità per certe features utente.

Il team si ritiene tuttavia soddisfatto dell'esperienza fatta nell'applicare scrum e ne esce arrichito.

## Test-Driven Development
Il team, durante l'intero arco dello sviluppo, ha cercato di attenersi il più possibile alla metodologia di sviluppo test-driven, che richiede, per una certa funzionalità, lo sviluppo prima del test e poi dell'implementazione. Questa metodologia dovrebbe aiutare lo sviluppatore a pensare al proprio software dal punto di vista dell'utilizzatore, a sviluppare codice robusto e crescere la codebase dei test assieme a quella del software che verrà utilizzato dall'utente finale. Nonostante i membri del team abbiano provato fin da subito a sviluppare in maniera strettamente test-driven, hanno tuttavia incontrato difficoltà a seguire la metodologia laddove non fosse sufficientemente chiaro il design da implementare o il requisito da soddisfare. 
Il team si è tuttavia impegnato a sviluppare parallelamente le codebase di test e del software finale, poiché è sempre stato caricato in versione codice testato, e ciò ha contribuito a ridurre notevolmente i bug nascosti da errori tecnici.

## Git Flow
Il team ha seguito, durante l'intero processo di sviluppo del software, il workflow "GitFlow", che consisteva nel produrre diversi feature branch, collegando ogni feature sufficientemente testata e avanti nello sviluppo ad un branch principale tramite il meccanismo di branch merging. Questo approccio ha permesso al team di suddividere agevolmente il lavoro e di mantenere ben separate le responsabilità dei vari membri.